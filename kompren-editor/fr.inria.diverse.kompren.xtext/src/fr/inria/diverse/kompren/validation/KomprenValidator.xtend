/*
 * generated by Xtext
 */
package fr.inria.diverse.kompren.validation

import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.URL
import kompren.KomprenPackage
import kompren.Slicer
import org.eclipse.xtext.validation.Check
import kompren.Constraint
import kompren.SlicedClass
import kompren.SlicedProperty

/**
 * Custom validation rules. 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class KomprenValidator extends AbstractKomprenValidator {

	public static val INVALID_URI = 'invalidURI'
	public static val NO_VARDECL = 'noVarDeclWhileRequired'
	public static val ONLY_GENMODEL = 'onlyGenmodel'
	public static val NO_VARDECL4EXP = 'exprRequiresVarDecl'

	/** Checks that VarDecl instances are defined when an expression is specified on a sliced class. */
	@Check def checkSlicedClassExpressionImpliesVariable(SlicedClass sc) {
		if(!sc.expression.nullOrEmpty && sc.ctx==null)
				error("Defining an expression on a sliced class requires the definition of 'ctx'", KomprenPackage.Literals.SLICED_CLASS__CTX, NO_VARDECL4EXP)
	}


	/** Checks that VarDecl instances are defined when an expression is specified on a sliced property. */
	@Check def checkSlicedPropertyExpressionImpliesVariable(SlicedProperty sc) {
		if(!sc.expression.nullOrEmpty && (sc.src==null || sc.tgt==null))
				error("Defining an expression on a sliced property requires the definition of both 'src' and 'tgt'", KomprenPackage.Literals.SLICED_PROPERTY__SRC, NO_VARDECL4EXP)
	}
	

	/** Checks that VarDecl instances are defined when constraints are specified. */
	@Check def checkConstraintImpliesVariable(Constraint cst) {
		val container = cst.eContainer
		if(container instanceof SlicedClass) {
			if(container.ctx==null)
				error("Defining a constraint requires the definition of 'ctx' in the sliced class", KomprenPackage.Literals.CONSTRAINT__NAME, NO_VARDECL)
		}
		else if(container instanceof SlicedProperty)
			if(container.src==null || container.tgt==null)
					error("Defining a constraint requires the definition of both 'src' and 'tgt' in the sliced property", KomprenPackage.Literals.CONSTRAINT__NAME, NO_VARDECL)
	}


	/** Checks that the given URIs are existing genmodel files. */
	@Check def checkURI(Slicer slicer) {
		val suffix = '.genmodel'
		slicer.uriMetamodel.forEach[uri |
			try {
				if(!uri.endsWith(suffix))
					error("Only genmodel can be used as input domain.", KomprenPackage.Literals.SLICER__URI_METAMODEL, ONLY_GENMODEL)
				val url = new URL(uri)
				val stream = url.openConnection.getInputStream
				val in = new BufferedReader(new InputStreamReader(stream))
				in.close
				stream.close
			}catch(Exception ex) {
				error("Cannot resolve this URI.", KomprenPackage.Literals.SLICER__URI_METAMODEL, INVALID_URI)
			}
		]
	}
}
