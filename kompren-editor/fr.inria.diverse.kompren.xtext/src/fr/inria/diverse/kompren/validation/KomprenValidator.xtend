/*
 * generated by Xtext
 */
package fr.inria.diverse.kompren.validation

import java.io.BufferedReader
import java.io.InputStreamReader
import java.net.URL
import java.util.Map
import java.util.Set
import kompren.Constraint
import kompren.KomprenPackage
import kompren.SlicedClass
import kompren.SlicedProperty
import kompren.Slicer
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class KomprenValidator extends AbstractKomprenValidator {

	public static val INVALID_URI = 'invalidURI'
	public static val NO_VARDECL = 'noVarDeclWhileRequired'
	public static val ONLY_GENMODEL = 'onlyGenmodel'
	public static val NO_VARDECL4EXP = 'exprRequiresVarDecl'

	/** Checks that the sliced classes and properties are sliced only a single time. */
	@Check def checkUniqueSlicedClassProperty(Slicer slicer) {
		if(slicer==null) return;
		val Set<EClass> set = newHashSet
		slicer?.slicedElements.filter(SlicedClass).filter[domain!=null].forEach[se |
			if(set.contains(se.domain))
				error("A sliced class must be unique: " + se.domain.name, se, KomprenPackage.Literals.SLICED_ELEMENT__DOMAIN)
				set.add(se.domain)
		]

		val Map<EStructuralFeature,SlicedProperty> props = newHashMap
		slicer?.slicedElements.filter(SlicedProperty).filter[domain!=null].forEach[se |
			val elt = props.get(se.domain)
			if(elt!=null && (se.opposite==elt.opposite || (se.opposite!=null && elt.opposite!=null)))
				error("A sliced property must be unique: " + se.domain.name, se,  KomprenPackage.Literals.SLICED_ELEMENT__DOMAIN)
			else
				props.put(se.domain, se)
		]
	}


	/** Checks that VarDecl instances are defined when an expression is specified on a sliced class. */
	@Check def checkSlicedClassExpressionImpliesVariable(SlicedClass sc) {
		if(sc==null) return;
		if(!sc.expression.nullOrEmpty && sc.ctx==null)
				error("Defining an expression on a sliced class requires the definition of 'ctx'", KomprenPackage.Literals.SLICED_CLASS__CTX, NO_VARDECL4EXP)
	}


	/** Checks that VarDecl instances are defined when an expression is specified on a sliced property. */
	@Check def checkSlicedPropertyExpressionImpliesVariable(SlicedProperty sc) {
		if(sc==null) return;
		if(!sc.expression.nullOrEmpty && (sc.src==null || sc.tgt==null))
				error("Defining an expression on a sliced property requires the definition of both 'src' and 'tgt'", KomprenPackage.Literals.SLICED_PROPERTY__SRC, NO_VARDECL4EXP)
	}
	

	/** Checks that VarDecl instances are defined when constraints are specified. */
	@Check def checkConstraintImpliesVariable(Constraint cst) {
		if(cst==null) return;
		val container = cst.eContainer
		if(container instanceof SlicedClass) {
			if(container.ctx==null)
				error("Defining a constraint requires the definition of 'ctx' in the sliced class", KomprenPackage.Literals.CONSTRAINT__NAME, NO_VARDECL)
		}
		else if(container instanceof SlicedProperty)
			if(container.src==null || container.tgt==null)
					error("Defining a constraint requires the definition of both 'src' and 'tgt' in the sliced property", KomprenPackage.Literals.CONSTRAINT__NAME, NO_VARDECL)
	}


	/** Checks that the given URIs are unique and existing genmodel files. */
	@Check def checkURI(Slicer slicer) {
		if(slicer==null) return;
		val suffix = '.genmodel'

		slicer?.uriMetamodel.forEach[uri |
			try {
				if(!uri.endsWith(suffix))
					error("Only genmodel can be used as input domain.", KomprenPackage.Literals.SLICER__URI_METAMODEL, ONLY_GENMODEL)

				val url = new URL(uri)
				val stream = url.openConnection.getInputStream
				val in = new BufferedReader(new InputStreamReader(stream))
				in.close
				stream.close
			}catch(Exception ex) {
				error("Cannot resolve this URI.", KomprenPackage.Literals.SLICER__URI_METAMODEL, INVALID_URI)
			}
		]
	}
}
